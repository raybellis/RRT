{"name":"RRT","tagline":"Ray's Ray Tracer","body":"# RRT - Ray's Ray Tracer\r\n\r\nRRT is a _stochastic_, _multithreaded_ ray tracer written in C++ that relies on casting a very high number of samples per pixel into the scene and then scatters diffuse rays in every direction.\r\n\r\nThe method is far from efficient and producing a noise-free image may take thousands of samples per pixel (and hours of CPU time) but it produces effects \"for free\" that many other ray tracers can only approximate, including:\r\n- diffuse inter-reflection (colour bleeding)\r\n- area lighting and soft shadow\r\n- glossy surfaces\r\n- depth-of-field\r\n- caustics\r\n\r\nThe current implementation supports only a limited number of 3D primitives:\r\n- spheres (of course!)\r\n- cubes\r\n- infinite planes\r\n- compound (parent node for collections of the above)\r\n\r\nArbitrary homogenous transformations are supported to move and deform primitives, but as yet these transformations cannot be nested.  That is to say, a compound node cannot yet have a transformation that applies to all child nodes within it.\r\n\r\nThere is no scene description language - the user has to write a C++ program that makes call to the RRT APIs that create nodes, attach shaders to nodes, etc.   See the example programs in `scenes/` for more details.\r\n\r\nThe most powerful shader is `Shader::stochastic` that can take a `surface` object that is similar to those used in other ray tracers and will automatically cast a single diffuse ray, a specular reflected ray and a tranmitted ray, depending on the surface's properties.\r\n\r\nFor a surface that has purely diffuse lighting properties the `Shader::diffuse` shader can be used instead and is slightly more efficient than `Shader::stochastic` because it doesn't have to consider the surface properties to decide whether to cast any non-diffuse rays.\r\n\r\nThere are no \"lights\" in RRT.  Any object can have a `Shader::constant` shader attached to it that makes that object a fixed colour and indirectly causes it to \"illuminate\" any object that casts a ray in its direction.\r\n\r\n## Compiling\r\n\r\nRRT requires a C++11 compatible compiler, Boost, GD, libpng, libjpeg and libz.  The supplied Makefile is for Mac OS X with macports.\r\n\r\n## Running\r\n\r\nTwo samples scenes are included so far, \"snooker\" and \"cornell\".\r\n\r\nThe demo programs will either start a new render, or if passed a `.rrt` file as parameter will use that as the starting render buffer state.  Every minute the current render buffer is rewritten to the `.rrt` file, as well as a 48-bpp PPM file.   The `netpbm` package can be used to convert  PPM files into PNG or JPEG, or many other formats.\r\n\r\n## TODO\r\n- More primitives (especially meshes!)\r\n- Bounding volume / Spatial acceleration techniques\r\n- Compound transformations\r\n- Time-based transformations (motion blur!)\r\n- Ensure partial frames can't end up in the `.rrt` files\r\n\r\n## Sample Image\r\n\r\n2048 samples per pixel, scaled 0.5, brightened slightly (`pnmnorm -wv 160`) and converted to JPEG with quality 95\r\n\r\n![](https://dl.dropboxusercontent.com/u/4713475/RRT/snooker.jpg)","google":"UA-59299711-1","note":"Don't delete this file! It's used internally to help with page regeneration."}